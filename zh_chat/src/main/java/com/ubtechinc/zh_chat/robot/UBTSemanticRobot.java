package com.ubtechinc.zh_chat.robot;import android.content.Context;import android.os.Handler;import android.os.HandlerThread;import android.os.Looper;import android.os.Message;import android.support.annotation.IntDef;import android.text.TextUtils;import com.ubtech.utilcode.utils.LogUtils;import com.ubtechinc.alpha.model.speech.SlotValue;import com.ubtechinc.alpha.sdk.SdkConstants;import com.ubtechinc.alpha.sdk.led.LedRobotApi;import com.ubtechinc.alpha.sdk.motion.MotionRobotApi;import com.ubtechinc.alpha.sdk.speech.SpeechConstant;import com.ubtechinc.alpha.sdk.speech.SpeechRobotApi;import com.ubtechinc.alpha.serverlibutil.aidl.ActionInfo;import com.ubtechinc.alpha.serverlibutil.interfaces.ActionListResultListener;import com.ubtechinc.alpha.serverlibutil.interfaces.ActionResultListener;import com.ubtechinc.alpha.serverlibutil.interfaces.MotorMoveAngleResultListener;import com.ubtechinc.alpha.serverlibutil.interfaces.SpeechASRListener;import com.ubtechinc.alpha.serverlibutil.interfaces.SpeechInitGrammarListener;import com.ubtechinc.alpha.serverlibutil.interfaces.SpeechTtsListener;import com.ubtechinc.alpha.serverlibutil.interfaces.SpeechWakeUpListener;import com.ubtechinc.alpha.serverlibutil.interfaces.StopActonResultListener;import com.ubtechinc.nlu.iflytekmix.ExcelSemantic;import com.ubtechinc.nlu.iflytekmix.ExcelSemanticResolver;import com.ubtechinc.nlu.iflytekmix.MixSemantic;import com.ubtechinc.nlu.iflytekmix.NetSemantic;import com.ubtechinc.nlu.iflytekmix.OfflineSemantic;import com.ubtechinc.nlu.strategy.DefaultSemanticStrategy;import com.ubtechinc.nlu.strategy.SemanticStrategyFactory;import com.ubtechinc.nlu.strategy.SpeechGrammarStrategy;import com.ubtechinc.zh_chat.business.BaseBusiness;import com.ubtechinc.zh_chat.business.BreatheTaskBusiness;import com.ubtechinc.zh_chat.business.CameraBusiness;import com.ubtechinc.zh_chat.business.ChatBusiness;import com.ubtechinc.zh_chat.business.LocalRobotActionBusiness;import com.ubtechinc.zh_chat.business.PlayBusiness;import com.ubtechinc.zh_chat.business.RobotActionBusiness;import com.ubtechinc.zh_chat.business.SelfBriefBusinesss;import com.ubtechinc.zh_chat.business.SleepTaskBusiness;import com.ubtechinc.zh_chat.business.TimerTaskBusiness;import com.ubtechinc.zh_chat.utils.ActionUtil;import com.ubtechinc.zh_chat.utils.FileUtil;import com.ubtechinc.zh_chat.utils.MixSemanticUtil;import java.lang.ref.WeakReference;import java.util.ArrayList;import java.util.List;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicBoolean;import timber.log.Timber;/** * @author: Logic * @email : 2091843903@qq.com * @time : 2017/3/23 * @desc : UBT中文机器人 */public final class UBTSemanticRobot {    private static ScheduledExecutorService twoSecondTimer = Executors.newScheduledThreadPool(1);    public static final int UNINIT = 0;    public static final int IDLE = 1;    public static final int GRAMMARING = 2;    public static final int THINKING = 4;    public static final int TTSING = 8;    public static final int ACTIONING = 16;    public UBTSemanticRootProxy getHandler() {        return mRobotProxy;    }    @IntDef(value = {UNINIT, IDLE, GRAMMARING, THINKING, ACTIONING, TTSING})    public @interface SemaRobotState {}    private int state = UNINIT;    private class CancelableRunnable implements Runnable{        private volatile AtomicBoolean canceled = new AtomicBoolean(false);        public void cancel(){            canceled.set(true);        }        @Override        public void run() {            if(canceled.get()) return;            ChatBusiness b = new ChatBusiness(cxt);            b.setAnswerText("我想想");            doRobotBusiness(b);        }    }    private CancelableRunnable timerTask;    public interface UBTSemanticRobotStateObserver {        void notifyRobotStateChange(int state);    }    private ArrayList<WeakReference<UBTSemanticRobotStateObserver>> observers = new ArrayList<>(1);    public interface RobotRequestOpenCameraHandler {        void requestOpenCamera();    }    public void registerStateObserver(UBTSemanticRobotStateObserver observer) {        observers.add(new WeakReference<>(observer));    }    public void unregisterStateObserver(UBTSemanticRobotStateObserver observer) {        for (int i = 0; i < observers.size(); i++) {            if (observers.get(i).get() == observer) {                observers.remove(i);                return;            }        }    }    private RobotRequestOpenCameraHandler openCameraHandler;    public void setCameraHandler(RobotRequestOpenCameraHandler handler) {        this.openCameraHandler = handler;    }    public interface ISpeechTTSFinishedListener {        void onTTSComplete();    }    private static final int WHAT_TYPE_THINKING = 1;    private static final int WHAT_TYPE_BUSINESSING = 2;    @IntDef(value = {WHAT_TYPE_THINKING, WHAT_TYPE_BUSINESSING})    public @interface WhatType {    }    private final ThinkingThread thinker;    class ThinkingThread extends HandlerThread {        public ThinkingThread() {            super("Semanticer", Thread.MAX_PRIORITY);        }    }    private ThinkingHandler thandler;    class ThinkingHandler extends Handler {        public ThinkingHandler(Looper looper) {            super(looper);        }        @Override        public void handleMessage(Message msg) {            @WhatType int what = msg.what;            LogUtils.i("begin understander...");            if (what == WHAT_TYPE_THINKING && addState(THINKING)) {                SpeechGrammarStrategy strategy = SemanticStrategyFactory.createIESemanticStrategy(cxt);                //计时2秒，提示tts"我想想";                timerTask = new CancelableRunnable();                twoSecondTimer.schedule(timerTask, 2, TimeUnit.SECONDS);                boolean success = false;                try {                    success = strategy.speechGrammarProcess((String) msg.obj);                } catch (Exception e) {                    LogUtils.w("speech Grammar Process fail：" + e.getMessage());                } finally {                    LogUtils.i("end understander...");                    timerTask.cancel();                    removeState(THINKING);                }                MixSemantic semantic = null;                if (success) {                    if (strategy instanceof DefaultSemanticStrategy) {                        semantic = ((DefaultSemanticStrategy) strategy).getSemantic();                    }                }                BaseBusiness business = null;                if (semantic == null) {                    LogUtils.W("semantic from : %s", MixSemantic.froms[0]);                    business = MixSemanticUtil.noAnswerChatBusiness(cxt);                } else {                    if (semantic.getFrom() == MixSemantic.FROM_EXCEL) {                        ExcelSemantic temp = (ExcelSemantic) semantic;                        business = MixSemanticUtil.resolveBusiness(cxt, temp);                    } else if (semantic.getFrom() == MixSemantic.FROM_SERVER) {                        NetSemantic temp = (NetSemantic) semantic;                        business = MixSemanticUtil.resolveBusiness(cxt, temp);                    } else if (semantic.getFrom() == MixSemantic.FROM_LOCAL) {                        OfflineSemantic temp = (OfflineSemantic) semantic;                        if (temp.getSlot() == SlotValue.GREET){                            ExcelSemantic excelSemantic = (ExcelSemantic) new ExcelSemanticResolver(cxt, temp.getSpeechResult()).resolve((String) msg.obj);                            if (excelSemantic != null) {                                business = MixSemanticUtil.resolveBusiness(cxt, excelSemantic);                                semantic = excelSemantic;                            }                        }else {                            business = MixSemanticUtil.resolveBusiness(cxt, temp);                        }                    } else {                        business = MixSemanticUtil.resolveBusiness(cxt, semantic);                    }                    LogUtils.D("semantic from : %s", semantic.fromStr());                    if (business == null) {                        business = MixSemanticUtil.noAnswerChatBusiness(cxt);                    }                }                doRobotBusiness(business);            }        }    }    private final RobotBusinessThread businesser;    class RobotBusinessThread extends HandlerThread {        public RobotBusinessThread() {super("Businesser");}    }    private BusinessHandler businessHandler;    private Semaphore actionSemaphore = new Semaphore(1);    class BusinessHandler extends Handler {        public BusinessHandler(Looper looper) {            super(looper);        }        @Override        public void handleMessage(Message msg) {            final @WhatType int what = msg.what;            LogUtils.i("11111");            if (what == WHAT_TYPE_BUSINESSING) {                BaseBusiness business = (BaseBusiness) msg.obj;                LogUtils.D("handle business = %s, operation = %s", business.toString(),                        business.getOperation());                if (business instanceof CameraBusiness) {                    stopScheduleBusiness();                    if (openCameraHandler != null) {                        openCameraHandler.requestOpenCamera();                    }                }                stopScheduleBusiness();                mCurBusiness = business;                business.start(mRobotProxy);            }        }    }    private Semaphore ttsSemaphore = new Semaphore(1);    private Context cxt;    private final byte[] lock = new byte[0];    private SleepTaskBusiness mSleepTask;    private BaseBusiness mTimerTask;    private BaseBusiness mBreatheTask;    private BaseBusiness mCurBusiness;    private boolean savePower = false;    private boolean breathEnable = false;    //是否离线语法构建成功    private volatile boolean isOfflineGrammarBuildSuccessed = false;    public void setSavePower(boolean savePower) {        this.savePower = savePower;        if (savePower){            stopScheduleBusiness();        }    }    private MotionRobotApi mActionApi;    private SpeechRobotApi mSpeechApi;    private LedRobotApi mLedRobotApi;    public UBTSemanticRobot(Context context) {        this.cxt = context.getApplicationContext();        businesser = new RobotBusinessThread();        thinker = new ThinkingThread();        mActionApi = MotionRobotApi.get();        mSpeechApi = SpeechRobotApi.get();        mLedRobotApi = LedRobotApi.get();    }    private void init() {        mSpeechApi.registerWakeUpListener(wakeUp);        mSpeechApi.speechInitGrammar(FileUtil.readAssetsFile2String(cxt, "call.bnf", "utf-8"), grammarInit);        mSpeechApi.speechSetVoiceName(SpeechConstant.IflySpeech.NAN_NAN);        businessHandler.postDelayed(new Runnable() {            @Override            public void run() {                mActionApi.getActionList(actionList);                doRobotBusiness(new SelfBriefBusinesss(cxt));                startScheduleBusiness();            }        }, 500);    }    public void start() {        businesser.start();        businessHandler = new BusinessHandler(businesser.getLooper());        thinker.start();        thandler = new ThinkingHandler(thinker.getLooper());        init();    }    /**复位*/    public void reset() {        Timber.d("reset robot...");        thandler.removeMessages(WHAT_TYPE_THINKING);        businessHandler.removeMessages(WHAT_TYPE_BUSINESSING);        stopScheduleBusiness();        startScheduleBusiness();        stopAction(false);        stopTTS(false);        if (mCurBusiness != null)            mCurBusiness.clean(mRobotProxy);        LogUtils.D("state=0x%s, tts permits=%d, action permits=%d",                Integer.toHexString(state),                ttsSemaphore.availablePermits(),                actionSemaphore.availablePermits());        mRobotProxy.start_Grammar();    }    public void quit() {        if (businesser != null)            businesser.quit();        if (thinker != null)            thinker.quit();        if (mRobotProxy != null) {            mRobotProxy.stop_TTS();            mRobotProxy.stop_Action();            mRobotProxy.stop_Grammar();            mRobotProxy = null;            mActionApi = null;        }        updateState(UNINIT);    }    public void startScheduleBusiness() {        businessHandler.post(new Runnable() {            @Override            public void run() {                if (savePower) {                    if (mSleepTask == null || mTimerTask == null) {                        mSleepTask = new SleepTaskBusiness(cxt);                        mTimerTask = new TimerTaskBusiness(cxt, mSleepTask);                    }                    mTimerTask.start(mRobotProxy);                }                if (!savePower && breathEnable) {                    if (mBreatheTask == null)                        mBreatheTask = new BreatheTaskBusiness(cxt);                    mBreatheTask.start(mRobotProxy);                }            }        });    }    public void stopScheduleBusiness() {        if (mTimerTask != null) {            mTimerTask.clean(mRobotProxy);            mTimerTask = null;        }        if (mBreatheTask != null) {            mBreatheTask.clean(mRobotProxy);            mBreatheTask = null;        }    }    private boolean updateState(int newState) {        boolean change = false;        synchronized (lock) {            if (this.state != newState) {                this.state = newState;                change = true;            }        }        LogUtils.D("after updateState: current state=0x%s,change=%s",                Integer.toHexString(newState), change);        if (change && observers.size() > 0) {            for (WeakReference<UBTSemanticRobotStateObserver> observer : observers) {                UBTSemanticRobotStateObserver ob = observer.get();                if (ob != null)                    ob.notifyRobotStateChange(newState);            }        }        return change;    }    private boolean addState(int addState) {        boolean change = false;        int newState = -1;        synchronized (lock) {            do {                if (addState == THINKING && this.state != IDLE) {                    change = false;                    break;                }                newState = (this.state & addState);                if (newState == 0) {                    newState = this.state == IDLE ? addState : (this.state |= addState);                    this.state = newState;                    change = true;                }            } while (false);        }        if (newState > 0)            LogUtils.D("after addState: current state=0x%s,change=%s,addState=0x%s",                    Integer.toHexString(newState),change, Integer.toHexString(addState));        if (change && observers.size() > 0) {            for (WeakReference<UBTSemanticRobotStateObserver> observer : observers) {                UBTSemanticRobotStateObserver ob = observer.get();                if (ob != null)                    ob.notifyRobotStateChange(newState);            }        }        return change;    }    private boolean removeState(int removeState) {        boolean change = false;        int newState;        synchronized (lock) {            newState = (this.state & removeState);            if (newState == removeState) {                this.state ^= removeState;                newState = this.state == 0 ? IDLE : this.state;                this.state = newState;                change = true;            }        }        if (newState > 0)            LogUtils.D("after removeState: current state=0x%s,change=%s,removeState=0x%s",                    Integer.toHexString(newState), change, Integer.toHexString(removeState));        if (change && observers.size() > 0) {            for (WeakReference<UBTSemanticRobotStateObserver> observer : observers) {                UBTSemanticRobotStateObserver ob = observer.get();                if (ob != null)                    ob.notifyRobotStateChange(newState);            }        }        return change;    }    private boolean isTTSing() {        synchronized (lock) {            return (this.state & TTSING) > 0;        }    }    private boolean isActioning() {        synchronized (lock) {            return (this.state & ACTIONING) > 0;        }    }    private boolean isGrammaring() {        synchronized (lock) {            return (this.state & GRAMMARING) > 0 && mSpeechApi.isSpeechGrammar();        }    }    private boolean idle(){        synchronized (lock){            return (this.state == IDLE) &&                    !(mCurBusiness instanceof PlayBusiness);        }    }    public void doSemanticResolve(String semStr) {        Message msg = thandler.obtainMessage(WHAT_TYPE_THINKING, semStr);        thandler.sendMessage(msg);    }    public void doRobotBusiness(BaseBusiness business) {        Message msg = businessHandler.obtainMessage(WHAT_TYPE_BUSINESSING, business);        businessHandler.sendMessage(msg);    }    private ISpeechTTSFinishedListener listener;    public UBTSemanticRootProxy mRobotProxy = new UBTSemanticRootProxy() {        @Override        public void start_TTS(String text, boolean isNeedAction) {            if (TextUtils.isEmpty(text)) return;            startTTS(text);            if (isNeedAction) {                String actionName = ActionUtil.getRandomAction(text);                startAction(actionName);            }        }        @Override        public void start_TTS(ISpeechTTSFinishedListener listener, String text, boolean isNeedAction) {            UBTSemanticRobot.this.listener = listener;            start_TTS(text, isNeedAction);        }        @Override        public void stop_TTS() {            stopTTS(true);        }        @Override        public void start_Action(String action) {            startAction(action);        }        @Override        public void stop_Action() {            stopAction(true);        }        @Override        public void start_Grammar() {            LogUtils.i("start grammar...");            if (updateState(GRAMMARING) || isGrammaring()) {                mSpeechApi.startSpeechASR(999,grammar);            }        }        @Override        public void stop_Grammar() {            LogUtils.i("stop grammar...");            if (removeState(GRAMMARING)) {                mSpeechApi.stopSpeechASR();            }        }        @Override        public void switchWakeup(boolean enable) {            Timber.d("switchWakeup...%s",enable);            if (enable) {                if (updateState(IDLE))                    mSpeechApi.switchWakeup(true);            }else {                updateState(UNINIT);                mSpeechApi.switchWakeup(false);            }        }        @Override        public boolean isActioning() {            return UBTSemanticRobot.this.isActioning();        }        @Override        public boolean isTTSing() {            return UBTSemanticRobot.this.isTTSing();        }        @Override        public boolean startLocalFunction(String function) {            mSpeechApi.startLocalFunction(function);            return true;        }        @Override        public void enterSavePowerMode() {            LogUtils.i("enter save power mode...");            stopAction(true);            stopTTS(true);            mActionApi.setPowerSaveMode(true);        }    };    private void moveHeadMotor(int angle) {        mActionApi.moveToAbsoluteAngle(19, angle, (short) 500, motorAngle);    }    private  void startTTS(String text) {        Timber.d("start tts : %s", text);        if (TextUtils.isEmpty(text)) return;        try {            int permits = ttsSemaphore.availablePermits();            LogUtils.D("tts semaphore permits= %d", permits);            if (permits > 0) {                ttsSemaphore.acquire(permits);            } else {                ttsSemaphore.acquire(1);            }            LogUtils.D("do TTS : %s", text);            if (addState(TTSING)) {                mRobotProxy.stop_Grammar();                int code = mSpeechApi.speechStartTTS(text, tts);                if (code != SdkConstants.ErrorCode.RESULT_SUCCESS) {                    stopTTS(true);                }            } else {                LogUtils.w("TTS state isn't match tts semaphore...stop tts");                stopTTS(true);            }        } catch (InterruptedException e) {            LogUtils.w(e.getMessage());        }    }    private  void stopTTS(boolean needCallApi) {        if (removeState(TTSING) || ttsSemaphore.availablePermits() <= 0) {            ttsSemaphore.release();            if (needCallApi)                mSpeechApi.speechStopTTS();            if (idle() &&                    !(mCurBusiness instanceof RobotActionBusiness) &&                    !(mCurBusiness instanceof LocalRobotActionBusiness)){                mRobotProxy.start_Grammar();            }        }    }    private  void startAction(String actionName) {        LogUtils.D("start action: %s", actionName);        if (TextUtils.isEmpty(actionName)) return;        try {            int permits = actionSemaphore.availablePermits();            LogUtils.D("action semaphore permits= %d", permits);            if (permits > 0) {                actionSemaphore.acquire(permits);            } else {                actionSemaphore.acquire(1);            }            if (addState(ACTIONING)) {                LogUtils.D("do Action : %s", actionName);                stopScheduleBusiness();                int id = mActionApi.playAction(actionName, actionResult);                LogUtils.I("action id = %d", id);                if (id < 0) {//加事务后，不能返回id                    stopAction(false);                }            } else {                LogUtils.w("Action state isn't match action semaphore...");                stopAction(false);            }        } catch (InterruptedException e) {            LogUtils.w(e.getMessage());        }    }    private synchronized void stopAction(boolean needCallApi) {        if (removeState(ACTIONING) || actionSemaphore.availablePermits() <= 0) {            actionSemaphore.release();            if (needCallApi) {                mActionApi.stopAction(actionStop);            }            if (idle()){                mRobotProxy.start_Grammar();            }        }    }    private SpeechTtsListener tts = new SpeechTtsListener() {        @Override        public void onEnd() {            LogUtils.d("tts end...");            stopTTS(false);            if (listener != null) {                listener.onTTSComplete();                listener = null;            }        }    };    private SpeechWakeUpListener wakeUp = new SpeechWakeUpListener() {        @Override        public void onSuccess() {            LogUtils.D("wake up success...curState = 0x%s", Integer.toHexString(state));            if (mCurBusiness != null)                mCurBusiness.clean(mRobotProxy);            mRobotProxy.start_Grammar();        }        @Override        public void onError(int errCode, String errDes) {            LogUtils.D("wake up fail...errCode=%d, errStr=%s", errCode, errDes);        }    };    private ActionListResultListener actionList = new ActionListResultListener() {        @Override        public void onGetActionList(int nOpId, int nErr, List<ActionInfo> onArrAction) {            LogUtils.D("get action list...size = %d", onArrAction!=null? onArrAction.size() :"0");            ActionUtil.initActionList(onArrAction);        }    };    private ActionResultListener actionResult = new ActionResultListener() {        @Override        public void onPlayActionResult(int nOpId, int nErr) {            stopAction(false);            startScheduleBusiness();        }    };    private StopActonResultListener actionStop = new StopActonResultListener() {        @Override        public void onStopActionResult(int nErr) {            stopAction(false);            startScheduleBusiness();        }    };    private MotorMoveAngleResultListener motorAngle = new MotorMoveAngleResultListener() {        @Override        public void onMoveAngle(int nOpId, int nErr, int nRadian) {            //nothing        }    };    private SpeechASRListener grammar = new SpeechASRListener() {        @Override        public void onBegin() {        }        @Override        public void onEnd() {        }        @Override        public void onResult(String strResult) {            LogUtils.D("onSpeechGrammarResult = %s", strResult);            mRobotProxy.stop_Grammar();            doSemanticResolve(strResult);        }        @Override        public void onError(int nErrorCode) {            LogUtils.D("onSpeechGrammarError = %d", nErrorCode);        }    };    private SpeechInitGrammarListener grammarInit = new SpeechInitGrammarListener() {        @Override        public void onSpeechGrammarInitCallback(String grammarID, int nErrorCode) {            isOfflineGrammarBuildSuccessed = nErrorCode == SdkConstants.ErrorCode.RESULT_SUCCESS;            if (nErrorCode == SdkConstants.ErrorCode.RESULT_SUCCESS) {                  mRobotProxy.start_Grammar();            }else {                LogUtils.E("离线命令词构建失败...离线命令词无法使用...!!!!!");            }        }    };}