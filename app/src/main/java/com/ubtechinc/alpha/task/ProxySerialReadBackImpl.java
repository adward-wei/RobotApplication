/* * *  * *  *  * *  *  * Copyright (c) 2008-2017 UBT Corporation.  All rights reserved.  Redistribution, *  *  *  modification, and use in source and binary forms are not permitted unless otherwise authorized by UBT. *  *  * *  * * */package com.ubtechinc.alpha.task;import android.content.Context;import com.ubtech.utilcode.utils.ConvertUtils;import com.ubtech.utilcode.utils.LogUtils;import com.ubtech.utilcode.utils.notification.NotificationCenter;import com.ubtech.utilcode.utils.notification.Subscriber;import com.ubtechinc.alpha.app.AlphaApplication;import com.ubtechinc.alpha.cmds.chest.ChestCmds;import com.ubtechinc.alpha.cmds.header.HeadCmds;import com.ubtechinc.alpha.event.BatteryHighTemperatureEvent;import com.ubtechinc.alpha.event.BatteryUpgradeResultEvent;import com.ubtechinc.alpha.event.DCStateEvent;import com.ubtechinc.alpha.event.ElectricityEvent;import com.ubtechinc.alpha.event.ForbiddenChargePlayingEvent;import com.ubtechinc.alpha.event.KeyPressEvent;import com.ubtechinc.alpha.event.MotorUpgradeEvent;import com.ubtechinc.alpha.event.PIRResultEvent;import com.ubtechinc.alpha.event.PowerOffEvent;import com.ubtechinc.alpha.event.SerialReadBackEvent;import com.ubtechinc.alpha.event.SonarDistanceEvent;import com.ubtechinc.alpha.event.SoundDirectionEvent;import com.ubtechinc.alpha.ops.OpResult;import com.ubtechinc.alpha.ops.RobotOpsManager;import com.ubtechinc.alpha.ops.SerialOpResultListener;import com.ubtechinc.alpha.ops.TransparentOp;import com.ubtechinc.alpha.ops.sys.SetMutekeyLedOp;import com.ubtechinc.alpha.serial.SerialConstants;import com.ubtechinc.alpha.speech.SpeechServiceProxy;import com.ubtechinc.alpha.utils.SysUtils;import com.ubtechinc.alpha.wificonnect.Alpha2Connection;import timber.log.Timber;/** * @desc : 用于处理串口回读事件 * @author: Logic * @email : logic.peng@ubtech.com * @time : 2017/4/19 * @modifier: * @modify_time: */public class ProxySerialReadBackImpl extends AbstractProxyService {	private static final int MUTEKEY_CLICKSTATE_CHECK_INTERVAL = 3000;	private boolean isMuteKeyOn =false;	private double muteKeyDownTime = 0;	private Context mContext;	public ProxySerialReadBackImpl(Context context){		this.mContext = context;	}	@Override	public void onCreate() {		super.onCreate();	}	@Override	public void onDestroy() {		super.onDestroy();	}	@Override	public void registerEvent() {		super.registerEvent();		NotificationCenter.defaultCenter().subscriber(SerialReadBackEvent.class, subscriber);	}	@Override	public void unregisterEvent() {		super.unregisterEvent();		NotificationCenter.defaultCenter().unsubscribe(SerialReadBackEvent.class, subscriber);	}	private Subscriber<SerialReadBackEvent> subscriber = new Subscriber<SerialReadBackEvent>() {		@Override		public void onEvent(SerialReadBackEvent event) {			if (event.error != SerialConstants.ERR_OK)				return;			if (event.serialType == SerialConstants.TYPE_CHEST){				handleChestReadBackEvent(event);			}else if (event.serialType == SerialConstants.TYPE_HEADER){				handleHeaderReadBackEvent(event);			}		}	};	//头部串口事件处理	private void handleHeaderReadBackEvent(SerialReadBackEvent event) {		byte[] data = event.data;		switch (event.cmd){			case HeadCmds.HEADER_SEND_OBSTACLE:				break;			case HeadCmds.HEADER_SEND_TRANSFORM:				//透传数据, 只在2mic上，才会上报该事件				TransparentOp op = new TransparentOp(SerialConstants.TYPE_CHEST, data);				RobotOpsManager.get(mContext).executeOp(op, new SerialOpResultListener() {					@Override					public void onRecvOpResult(OpResult result) {						Timber.d(result.toString());					}				});				break;			case HeadCmds.HEADER_SEND_KEY:				handleHeaderKeyPressReport(data);				break;			case HeadCmds.HEADER_FALL_DERECTION:				break;			case HeadCmds.HEADER_SOUND_DIRECTION:				handleSoundDirectionReport(data);				break;			case HeadCmds.HEADER_HIGHT_TEMP:				break;		}	}	/**	 * 声音方向	 * @param data	 */	private void handleSoundDirectionReport(byte[] data) {		SoundDirectionEvent event = new SoundDirectionEvent();		event.direction = data[0];		event.angle = data[1];		NotificationCenter.defaultCenter().publish(event);	}	/**	 * 头部按键上报	 * @param data	 */	private void handleHeaderKeyPressReport(byte[] data) {		KeyPressEvent event =  new KeyPressEvent();		event.keyType = data[0];		NotificationCenter.defaultCenter().publish(event);	}	//胸部串口事件处理	private void handleChestReadBackEvent(SerialReadBackEvent event) {		byte[] data = event.data;		switch (event.cmd){			case ChestCmds.CHES_SEND_SHUTDWON:				// 收到硬件发过来的关机命令，android端清理完成后，回复一个确认关机指令				handlePowerOffReport(data);				break;			case ChestCmds.CHES_SEND_OBSTACLE:				//有障碍物				break;			case ChestCmds.CHES_MOTOR_TEMP_BEYOND:				//舵机温度过高				break;			case ChestCmds.CHES_SEND_TRANSFORM:				//透传数据				TransparentOp op = new TransparentOp(SerialConstants.TYPE_HEADER, data);				RobotOpsManager.get(mContext).executeOp(op, new SerialOpResultListener() {					@Override					public void onRecvOpResult(OpResult result) {						Timber.d(result.toString());					}				});				break;			case ChestCmds.CHES_SEND_ALARM:				//闹钟触发,不做处理				break;			case ChestCmds.CHES_SEND_POWER:				handleElectricityReport(data);				break;			case ChestCmds.CHEST_TOUCH_BOARD:				break;			case ChestCmds.CHES_DC_STATE:				//dc状态				handleDCReport(data);				break;			case ChestCmds.CHES_CHARGE_PLAY_RSP:				//禁止插着充电器控制舵机				handleChargPlayingReport(data);				break;			case ChestCmds.CHES_SONAR_DISTANCE:				//超声距离上报				handleSonarReport(data);				break;			case ChestCmds.CHES_DC_TEMP_BEYOND:				//电池温度过高				handleBatteryTempReport(data);				break;			case ChestCmds.CHES_MOTOR_UPGRADE:				handleMotorUpgradeReport(data);				break;			case ChestCmds.CHES_BATTERY_UPGRADE:				handleBatteryUpgradeResultReport(data);				break;			case ChestCmds.CHES_PIR_STATE:				handlePIRStateReport(data);				break;			case ChestCmds.CHES_MUTE_KEY_STATE:				handleMutekey(data);				break;			default:				break;		}	}	private void handleMutekey(byte[] data){		checkMuteKeyClickState(data);	}	private void checkMuteKeyClickState(byte[] data){		if(data[0]==1){//mute key press down			muteKeyDownTime =System.currentTimeMillis();		}else{// mute key up			double timeBetweenDownAndUp=System.currentTimeMillis()-muteKeyDownTime;			if(timeBetweenDownAndUp >= MUTEKEY_CLICKSTATE_CHECK_INTERVAL){				LogUtils.i(TAG,"mute key long click.");				mutekeyOnLongClick();			}else{//mute key short click				LogUtils.i(TAG,"mute key click.");				mutekeyOnClick();			}			muteKeyDownTime =0;		}	}	private void  mutekeyOnClick(){		if(isMuteKeyOn){			//关闭mute按键			RobotOpsManager.get(AlphaApplication.getContext()).executeOp(new SetMutekeyLedOp((byte)0));			SpeechServiceProxy.getInstance().switchWakeup(false);		}else{			//打开mute按键			RobotOpsManager.get(AlphaApplication.getContext()).executeOp(new SetMutekeyLedOp((byte)1));			SpeechServiceProxy.getInstance().switchWakeup(true);		}		isMuteKeyOn =!isMuteKeyOn;	}	private void mutekeyOnLongClick(){		Alpha2Connection connection = Alpha2Connection.getInstance(AlphaApplication.getContext());		if (!connection.isConnectingNow()) {			connection.beginNetworkConnection();		} else {			connection.stopNetworkConnection(true);		}	}	private void handleMuteKeyStateReport(byte[] data) {		if (data == null || data.length < 0) return;		if (data[1] == 1) return;//按下不处理, 松开处理		KeyPressEvent event = new KeyPressEvent();		event.keyType = 1;		NotificationCenter.defaultCenter().publish(event);	}	/**	 * 手动关机：用户按了胸部的关机按钮，发出的命令	 * @param data	 */	private void handlePowerOffReport(byte[] data) {		PowerOffEvent event = new PowerOffEvent();		NotificationCenter.defaultCenter().publish(event);	}	/**	 * 红外检测	 * @param data	 */	private void handlePIRStateReport(byte[] data) {		PIRResultEvent event = new PIRResultEvent();		event.valid = (data[0] == 1);		NotificationCenter.defaultCenter().publish(event);	}	/**	 * 电池包升级上报	 * @param data	 */	private void handleBatteryUpgradeResultReport(byte[] data) {		BatteryUpgradeResultEvent event = new BatteryUpgradeResultEvent();		event.success = data[0] == 0;		NotificationCenter.defaultCenter().publish(event);	}	/**	 * 处理电量上报命令	 * @param data	 */	private void handleElectricityReport(byte[] data) {		ElectricityEvent event = new ElectricityEvent();		if(SysUtils.is5Mic() && data.length == 3){			event.isCharging = (data[2] == 1);		} else if(SysUtils.is2Mic() && data[1] == -52){			event.isCharging = true;		}		event.isLowBattery = (data[0]== 0);		event.mPercentage = data[1];		NotificationCenter.defaultCenter().publish(event);	}	/**	 * 电池高温上报命令	 * @param data	 */	private void handleBatteryTempReport(byte[] data) {		if (data[0] == 1){			BatteryHighTemperatureEvent event = new BatteryHighTemperatureEvent();			NotificationCenter.defaultCenter().publish(event);		}	}	/**	 * DC上报	 * @param data	 */	private void handleDCReport(byte[] data) {		DCStateEvent event = new DCStateEvent();		event.isInserted = (data[0] == 1);		NotificationCenter.defaultCenter().publish(event);	}	/**	 * 处理：禁止插着充电器控制舵机事件上报	 * @param data	 */	private void handleChargPlayingReport(byte[] data) {		boolean isForbidden = (data[0]== ChestCmds.CMD_SEND_DATA_TO_MOTOR) ||				(data[0] == ChestCmds.CMD_SET_MOTOR_ANGLE && data[1]<= 18);//舵机id		ForbiddenChargePlayingEvent event = new ForbiddenChargePlayingEvent();		event.isForbiddenChargePlaying = isForbidden;		NotificationCenter.defaultCenter().publish(event);	}	/**	 * 超声上报	 * @param data	 */	private void handleSonarReport(byte[] data) {		SonarDistanceEvent event = new SonarDistanceEvent();		event.distance = data[0];		event.time = ConvertUtils.h_byte2Short(new byte[]{data[1], data[2]});		NotificationCenter.defaultCenter().publish(event);	}	/**	 * 舵机升级事件	 * @param data	 */	private void handleMotorUpgradeReport(byte[] data) {		MotorUpgradeEvent event = new MotorUpgradeEvent();		event.motorId = data[1];		event.success = (data[0] == 0);		NotificationCenter.defaultCenter().publish(event);	}}