package com.ubtechinc.alpha.utils;import android.content.Context;import android.content.pm.PackageInfo;import android.content.pm.PackageManager;import com.ubtech.utilcode.utils.LogUtils;import com.ubtechinc.alpha.cmds.chest.ChestCmds;import com.ubtechinc.alpha.cmds.header.HeadCmds;import com.ubtechinc.alpha.ops.OpResult;import com.ubtechinc.alpha.ops.RobotOpsManager;import com.ubtechinc.alpha.ops.SerialOpResultListener;import com.ubtechinc.alpha.ops.sys.ReadBatteryVersionOp;import com.ubtechinc.alpha.ops.sys.ReadChestVersionOp;import com.ubtechinc.alpha.ops.sys.ReadHeadVersionOp;import com.ubtechinc.alpha.robotinfo.SoftwareVersionInfo;/** * @desc : 软件版本收集器 * @author: wzt * @time : 2017/5/23 * @modifier: * @modify_time: */public class VersionCollector implements SerialOpResultListener<byte[]> {	private static VersionCollector sVersionCollector;	private Context mContext;	private VersionCollector(Context context) {		mContext = context.getApplicationContext();	}	public static VersionCollector get(Context context) {		if(sVersionCollector == null) {			synchronized (VersionCollector.class) {				if(sVersionCollector == null)					sVersionCollector = new VersionCollector(context);			}		}		return sVersionCollector;	}	public void requestVersion() {		ReadChestVersionOp readChestVersionOp = new ReadChestVersionOp();		RobotOpsManager.get(mContext).executeOp(readChestVersionOp, this);		if(SysUtils.is2Mic()) {			ReadHeadVersionOp readHeadVersionOp = new ReadHeadVersionOp();			RobotOpsManager.get(mContext).executeOp(readHeadVersionOp, this);		}		ReadBatteryVersionOp readBatteryVersionOp = new ReadBatteryVersionOp();		RobotOpsManager.get(mContext).executeOp(readBatteryVersionOp, this);		requestOtherVersion();	}	@Override	public void onRecvOpResult(OpResult<byte[]> result) {		if (result.data == null || result.data.length == 0) return;		if(result.cmd == ChestCmds.CMD_READ_VERSION) {			String chestVersion = SoftwareVersionUtils.parseVersion(result.data, result.data.length).getVersion();			SoftwareVersionInfo.get().chestVersion = chestVersion;			LogUtils.I("chest_verison = %s", chestVersion == null? "": chestVersion);		} else if(result.cmd == ChestCmds.CMD_POWER_INFO) {			String batteryVersion = SoftwareVersionUtils.parseBatteryVersion(result.data, result.data.length).getVersion();			SoftwareVersionInfo.get().batteryVersion = batteryVersion;			LogUtils.I("battery_Version = %s", batteryVersion == null? "": batteryVersion);		} else if(result.cmd == HeadCmds.CMD_READ_VERSION) {			String headVersion = SoftwareVersionUtils.parseVersion(result.data, result.data.length).getVersion();			SoftwareVersionInfo.get().headVersion = headVersion;			LogUtils.I("head_Version = %s", headVersion == null? "": headVersion);		}	}	private void requestOtherVersion() {		String packageName = mContext.getPackageName();		PackageInfo info;		try {			info = mContext.getPackageManager().getPackageInfo(packageName, 0);			SoftwareVersionInfo.get().serviceVersionName = info.versionName;			SoftwareVersionInfo.get().serviceVersionCode = info.versionCode;			LogUtils.d("service version=" + info.versionName);		} catch (PackageManager.NameNotFoundException e) {			e.printStackTrace();		}		SoftwareVersionInfo.get().deviceVersion = android.os.Build.VERSION.RELEASE;		LogUtils.d("device version=" + android.os.Build.VERSION.RELEASE);	}}